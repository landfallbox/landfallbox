---
layout: article
title: Java 笔记
article_header: 
  type: cover
  image:
    src: https://raw.githubusercontent.com/landfallbox/Pictures/master/202402171944706.png
tags: 
    - Java
---

# 注释

```java
// 这是第一种注释方式，但只能注释一行
```

```java
/* 
这是第二种注释方式，可以注释多行
*/
```

```java
/**
* 这是第三种注释方式，可以注释多行。与第二种的区别在于这种方式会通过 javadoc 工具自动生成注释文档。
* 这种注释方式有一定的格式，一般第一行为概要性的解释，之后每一行为自由格式文本，如下所示。
* @param 解释方法的参数
* @return 
* @throws
* @author
* @version
* @since
* @deprecated
* @see
*/
```

# 数据类型

Java是一种强类型语言，即必须为每一个变量声明一种类型。

Java中一共有八种基本类型，四种整型，两种浮点型，一种char型，一种boolean型。

四种整型为int、short、long、byte，分别为4字节、2字节、8字节、1字节。

两种浮点型为float、double，分别为4字节、8字节。

char型要用单引号括起来。 

boolean型和整型之间不能相互转换。

# 变量

## 声明

```java
int x;
```

##  初始化

```java
int x;
x = 0;
```

以上两个过程可以合并。

```java
int x = 0;
```

一般说来，变量的声明尽可能靠近变量第一次使用的地方是一种良好的编程风格。

## 常量

```java
final int x = 0;
```

被 final 修饰的变量叫做常量。常量只能被赋值一次，一旦赋值，不能修改。习惯上，常量名使用全大写。

如果想要定义类常量，即某个常量可以被一个类的多个方法使用，则应当使用 `static final` 。

```java
public class Demo{
    private static final x = 0;	// 如果声明为public，则其他类的方法也可以使用此常量。
}
```

# 数组

## 创建数组

```java
int[] a = new int[100];
```

数组长度不要求一定是常量，也可以是变量。

```java
int n = 100;
int[] a = new int[n];
```

数组定义也可以使用以下的形式，但不如上面的形式常用。

```java
int a[] = new int[100];
```

创建数组后，数组会被 Java 自动初始化。如果是数字数字，则都是0。如果是 boolean 数组，则都是 false。如果是对象数组，则都是 null。

数组创建后长度不能变化。如果希望数组的长度是可变的，应当使用 ArrayList。

## 数组遍历

如果希望逐个处理数组中的元素，可以使用for循环实现，但这样做的前提是必须先知道数组的长度。Java 中有一种增强的 for each 循环语句，可以在不使用下标的情况下遍历数组。

```text
for(variable : collection)
    statement
```

其中，variable 暂存集合中的每一个元素，collection 必须是一个数组或者是一个实现了 Iterable 接口的类对象。

## 数组初始化

一般数组的创建和初始化过程是先定义一个数组，再用循环对其中的元素赋值，但 Java 中有一种简化形式。

```java
int[] a = {1, 2, 3};
```

注意，这种形式是不需要使用 new 的。

## 匿名数组

```java
new int[] {1, 2, 3}
```

这会创建一个新数组并用括号中的值对它初始化，数组的长度为提供的值的个数。其主要作用是对一个已经初始化过的数组重新初始化。

```java
int[] a = {1, 2, 3};
a = new int[] {4, 5, 6};
```

Java 中数组的长度可以是 0。数组长度是 0 不等于 null。

## 复制数组

```java
int[] b = {1, 2, 3}；
int[] a = b;
```

此时 a 和 b 都代表同一个数组，对其中任何一个数组的元素改动都会影响另一个数组。

如果希望将一个数组的内容复制给另一个数组，并且两个数组相互独立，互不影响，可以使用如下的方法。

```java
import java.util.Arrays;

int [] b = {1, 2, 3};
int[] a = Arrays.copyOf(b, b.length);
```

其中，copyOf 的第一个参数是被复制的数组，第二个参数是新数组的长度。可以通过参数增加数组的长度，新数组相比于旧数组多余的部分会被默认初始化。如果新数组的长度更短，则只复制前面一部分。

## 数组排序

想对数组排序可以使用下面的这个方法。

```java
import java.util.Arrays;

int[] a = new int[100];
Arrays.sort(a);
```

这个方法是一个优化后的快速排序算法。快速排序算法对大多数数组来说效率都是比较高的。

# 类

## 基本构成

一个用户自定义类包括三个部分：实例域，构造器，方法。

虽然实例域可以用 public 修饰，但这样破坏了封装的效果，是极不提倡的做法。通常情况下实例域用 private 修饰。

构造器与类同名。每个类可以有多个构造器，不同的构造器之间通过参数的个数互相区分。构造器没有返回值。

方法一般是 public 修饰的，特殊情况下也可以有 private 修饰的方法。这种特殊情况往往是因为某个单个方法包含的内容过多，代码太长，为提高代码的可读性并降低代码的耦合，可以将其中的一部分代码封装成一个单独的方法供别的方法调用，因而这种方法是不需要暴露给类调用者的，只需要对某个类内部可见就行，所以无需使用 public 修饰。

> 由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。

## 实例域

### final 修饰实例域

被 final 修饰的实例域在构建对象时必须被初始化，即任何构造器执行后这个实例域的值都必须被设置，且一旦设置不可更改。这时，被修饰的实例域可以没有 setter 方法。

### static 修饰实例域

被 static 修饰的实例域属于该类而不是属于该类的某个实例对象，即使没有任何的实例对象，这个实例域也存在，可被访问。

### 静态常量

如果一个实例域同时被 static 和 final 修饰，那么它就被称作静态常量。它比单纯被 static 修饰的实例域更实用，也更常用。一般实例域是不可以设置为 public 的，但由于静态常量被 final 修饰，一旦赋值不可更改，所以没有这个限制。

```java
public class Math{
    public static final double PI = 3.14159265358979323846;
}
```

## 构造器

### 默认初始化

如果构造器中没有为所有的实例域显式初始化，那么没被初始化的实例域会被默认初始化，其原则是数值为0、布尔值为false、对象引用为null。但这样的代码极度缺乏可读性，极不建议这么做。

### 无参数的构造器

推荐为每个类都创建一个无参数的构造器，为每个实例域设置一个合适的初始值。

如果程序员没有编写任何构造器，那么系统会自动编写一个无参数的构造器，每个实例域被初始化为默认值，其原则与上述的默认初始化原则相同。

如果程序员编写了至少一个带参的构造器，这时系统不会自动编写一个无参数的构造器，试图通过无参数的构造器创建一个对象将被视为是非法的。

> 有时在很多的构造器中某个实例域都被初始化为相同的初始值，这情况下可以在实例域定义时就赋给其合适的初始值，这是一个可以大大减少开发量的技巧。

### this 的妙用

Java 程序员使用 this 提高构造器代码的可读性。具体参见以下的例子。

```java
public Man(String name, double salary){
    this.name = name;
    this.salary = salary;
}

public Man(String n, double s){
    name = n;
    salary = s;
}

// 显而易见，在以上两种构造器的代码中，前一种代码的可读性是远高于第二种的。前一种代码风格也是更加常见且推荐的。
```

还可以使用 this 在构造器中调用其他构造器。

```java
public Employee(double s){
    this("Employee #" + nextId, s);	// 调用 Employee(String, double)
    nextId++;
}
```

这意味着多个构造器的公共部分可以只编写一次，减少了代码编写量。

### 初始化块

除了构造器、声明时直接赋值外，Java 还支持一种机制实现实例域初始化：一种特殊的代码块，初始化块。

```java
class Employee{
    ...
    // staic // 如果是对静态域初始化则需要加 static
    {
        id = nextId;
        nextId++;
    }    
        
    ...    
}
```

无论调用哪个构造器构造对象，都会先执行代码块中的代码，然后才执行构造器中的内容。

这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中。如果一定要使用，虽然初始化块不必须放在实例域和构造器的代码之间，但还是建议放在这个位置。因为如果不这样做，将为编译器的实现带来很多麻烦，且可能带来循环定义的问题。

**不妨对上述所有内容做一个梳理，整理一下构造一个对象时究竟经过了哪些步骤：**

1. **所有数据域被初始化为默认值（0、false或null）。**
2. **按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。**
3. **如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。**
4. **执行这个构造器的主体。**

## 方法

### setter 和 getter

由于实例域是 private 修饰的，为了实现对实例域的访问或设置，一般要求为每个实例域给出 setter 和 getter 方法。这些方法是 public 修饰的。

当实例域的数量比较多时，为每个实例域都提供 setter 和 getter 是很麻烦的重复工作，有一些三方库可以帮助简化代码的开发和维护，如 Lombok。

### static 修饰方法

static 修饰的方法不能操作对象，即它不能访问任何非 static 修饰的实例域。这种方法也不是通过某个实例对象调用，而是直接通过类名调用。

```java
class Math{
    public static pow(x, a){
        ...
    }
}

// 下面的这种调用方式是错误的。
Math math = new Math();
y = math.pow(x, a);

// 下面的这种调用方式才是正确的
y = Math.pow(x, a);
```

> 其实 static 修饰的方法是可以通过实例对象访问的，其效果与通过类名访问是一样的，但这种方式极易引入混淆，所以是极不推荐的。

>  main 方法也是由 static 修饰的。其实，**可以为每个类都创建一个 main 方法，用于测试该类的某些内容。**

### 方法参数

在 Java 中，方法的参数有两种类型：基本数据类型和类的实例对象。

对于基本数据类型，其传递方式是按值传递，即方法得到的是参数的一个拷贝而不是参数本身。这意味着即使在方法中修改参数的值也不会影响到参数本身。

```java
public static void tripleVale(double x){
    x = 3 * x;
}

public static void main(String[] arg){
    double x = 0.1;
    tripleValue(x);
    System.out.println(x);	// 这时，x 的值依然是
}
```

如果是类的实例对象，其传递方式还是按值传递，但传递的值是对象的引用的一个拷贝而不是像基本数据类型那样的具体的内容，因而虽然是按值传递，但对参数的修改是会改变实例对象本身的内容的。

**不妨做一个易于记忆的总结：**

- **一个方法不能修改一个基本数据类型的参数。**
- **一个方法不能修改一个基本数据类型的参数。**
- **一个方法不能修改一个基本数据类型的参数。**

### 方法重载

Java 允许重载任何方法，包括构造器和普通的方法。同一个方法的不同重载之间的区别在于参数的类型和个数。

## 类的设计技巧

有必要简单总结类的设计技巧，以使得设计的类更符合 OOP 的专业水准。

1. 数据一定要私有

2. 数据一定要初始化

3. 不要在类中使用过多的基本类型

4. 不是所有的域都需要独立的域访问器和域更改器

5. 将职责过多的类进行分解

6. 类名和方法名要能够体现它们的职责

7. 优先使用不可更改的类 

   > 可更改对象的问题在于多线程并发问题。

## 类的组织方式

假设两个程序员创建了同名的类，第三个程序员在创建这个名称的类的对象时编译器就无法知道要创建的到底是哪个类的对象。要求每个类的名称都独一无二显然是不可能的，但可以通过将类放在不同的包中来区分同名类，这就是 Java 中使用包来组织和使用类的原因。

为了确保包名的唯一性，Sun 建议将公司的因特网域名（这显然是独一无二的）以逆序的形式作为包名，并且对于不同的项目使用不同的子包。如 对于 njtech.edu.cn ，其逆序为 cn.edu.njtech，且可以被划分为更多的子包：cn.edu.njtech.Test，cn.edu.njtech.Demo 等。

### 包的导入

一个类可以使用所属包中的所有类，以及其他包中的公有类。两种方式访问另一个包中的公有类：在每个类名之前添加完整的包名或使用 import 语句导入一个特定的类或者整个包。

```java
java.time.LocalDate today = java.time.LocalDate.now();

import java.util.*; // import java.util.LocalDate;
LocalDate today = LocalDate.now();
```

显然第一种方式过于繁琐。

在使用第二种方式实现包的导入时，明确地指出所导入的类将会使代码的可读性得到提升，但不是必须的。

在使用 * 时，只能用 * 代替一个包中的所有类，而不能指代其中的包。如下所示的几种方式都是错误的。

```java
import java.*;
import java.*.*;
```

### 静态导入

```java
import static java.lang.System.*;
```

如果使用上面的导入方式，称之为静态导入，可以在不加类名前缀的前提下使用 System 类的静态方法和静态类。

### 将类放入包中

```java
package cn.edu.njtech;

public class Employee{
    ...
}
```

如果没有使用 package 指定包，那么类被放在默认包中。默认包没有名字。

包名和目录名必须匹配。如果不匹配，源文件又依赖别的包，那么编译无法通过。如果不依赖别的包，那么编译不报错，但程序无法运行。因为虚拟机找不到类。

### JAR

类除了可以存在文件系统的目录中，还可以存在 JAR（Java 归类文档）中。一个 JAR 文件中可以包含多个压缩形式的类文件和子目录。JAR 常见于程序中需要使用第三方库时。三方库往往是以 JAR 的形式给出的。

> JAR 本质是 ZIP，可以使用 ZIP 工具查看 JAR 内部的具体内容。

# 继承

Java 中使用 extends 关键字表示继承。

```java
public class Manager extends Employee{
    // 新增加的y
    ...
}
```

Java 中的所有继承都是公有继承，没有私有继承和保护继承。

一般称被继承的类称为超类、基类、父类，新类称为子类、派生类、孩子类。最常用的是超类和子类的称呼。

子类可以重写父类的方法。

Java 中不支持多继承。

## 子类访问超类的域或方法

子类是不能直接访问超类的私有域的，只能通过超类提供的公有 getter 接口。同时，由于继承后子类和超类中存在同名方法，为了区分调用的到底是哪个方法，调用超类的方法时应当使用 super 。

```java
super.getId();
```

## 子类调用超类的构造器

子类使用 super 调用超类的构造器。值得注意的是，如果要使用 super 调用超类构造器，那么 super 必须是子类构造器的第一句。

```java
public Manager(){
    super();
    ...
}
```

如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认的构造器，即没有参数的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则Java编译器将报告错误。

## 多态

假设有 Employee 和 Manager 类，Manager 是 Employee 的子类。多态的意思是一个 Employee 类型的变量既可以引用 Employee 对象，也可以引用 Manager 对象。反之必须进行强制类型转换。

```java
Manager boss = new Manager();
Employee staff[] = new Employee[3];
staff[0] = boss;	// 根据多态，这是可以的

// 假设 Manager 中有一个 Employee 中没有的方法：setBonus
staff[0].setBonus(...);		// 这是非法的，因为 staff[0] 被编译器认为是 Employee 对象，而Employee 中没有 setBonus 方法
boss.setBonus(...);		// 这是合法的。
```

在进行强制类型转化时，如果不能转换成功，则会产生 ClassCastException 异常。如果没有捕获这个异常，那么程序就会终止。因此，推荐形成良好的习惯：在进行类型转换之前，先使用 instanceof 操作符查看一下是否能够成功地转换。

```java
if(x instanceof Manager){
    Manager m = (Manager) x;
}
```

当然，上述的强制类型转化其实不常见，也不推荐使用。只是有时必须如此时建议按照上述建议编程。

## 阻止继承

被 final 修饰的类不允许被继承，被 final 修饰的方法不能被覆盖。

## 抽象类和抽象方法

方法被 abstract 修饰称为抽象方法，包含抽象方法的类必须被 abstract 修饰，称为抽象类。

声明抽象方法时不可以写出大括号。

抽象方法的意义在于抽象类不必给出其具体的实现，但它的子类可以继承这个方法，并给出具体实现。如果子类只是继承而不给出具体实现，那么子类也必须被 abstract 修饰，成为抽象类。

如果一个类不包含抽象方法，它也可以被 abstract 修饰，成为抽象类。抽象类不能被实例化，即不存在抽象类的实例对象。但是可以存在抽象类的对象变量的，根据多态，它可以引用非抽象子类的对象。

## protected

有些时候，人们希望超类中的某个方法或某个域允许被子类访问，这时可以将这些方法或域声明为 `protected` 。

当然，在实际使用中要尽量谨慎，因为 `protected` 有可能带来数据封装的破坏。

至此，可以总结一下 Java 中的所有用于控制可见性的访问修饰符：

- private —— 仅对本类可见
- public —— 对所有类可见
- protected —— 对本包和所有子类可见
- 无修饰符 —— 默认，对本包可见

## Object

Java 中所有的类都是 `Object` 的子类，但并不要求显式地指明这个继承关系。如果某个类没有被明确显式指出它继承于哪个类，那么默认它继承自 `Object` 。

根据多态和上述信息，`Object` 类型的变量可以引用任意类的对象。

# 接口

接口不是一个类，而是对类的需求描述。**所有实现接口的类都必须实现接口中给出的方法**，其返回值，名称，参数列表必须完全相同。

```java
public interface Comparable{
    int compareTo(Object other);
}

public class Employee implements Comparable{
    ...
    public int compareTo(Object other){
        ...
    }
    ...
}
```

接口不能含有实例域，但可以包含常量。接口中的域被自动设为 public static final。

接口中的方法默认都是 public 修饰的，因而无需显式地指明 public。

由于接口不是类，所以接口不存在实例对象。但可以声明接口类型的变量，它只能引用实现了接口的类的对象。

如同使用 instanceof 检查一个对象是否属于某个特定类一样，也可以使用 instanceof 检查一个对象是否实现了某个特定的接口。

与类的继承相似，接口也可以被扩展，也使用 extends 关键字。

```java
public interface ... extends ...{
    ...
}
```

## “多重继承”

在 *C++* 中，一个类可以继承多个超类，这叫做多重继承。在 *Java* 中，一个类只能有一个超类，因而不存在严格意义上的多重继承。但多重继承本身是很有意义的，所以 *Java* 虽然不允许多重继承，却以另一种方式实现了与之相似的效果。

这种方式就是一个类虽然只能有一个超类，但可以实现多个接口。这样，既获得了多重继承的大多数好处，又避免了多重继承的复杂性和低效性。

## 默认方法（Java SE 8 以后）

*Java SE 8* 以后，可以为接口中的方法提供一个默认实现，这种方法被称为默认方法。在类实现接口时，默认方法可以不被覆盖实现。

```java
public interface Comparable<T>{
    default int compareTo(T other){
        return 0;
    }
}
```

引入默认方法的意义如下：如果某个类希望实现对鼠标点击的监听，则必须实现 MouseListener 接口。这个接口中有五个方法，分别监听包括鼠标点击在内的五种事件。如果没有默认方法，则必须覆盖着五个方法，而其中只有一个方法是我们实现程序功能需要的，其余的方法虽然不是我们关心的但必须得给出覆盖实现（很多时候是空，即什么都不做）。引入默认方法并为每个方法给出空白的默认实现之后，程序员只需要给出点击事件对应的方法的覆盖实现，而不需要关心其余还有什么方法。

默认方法的另一个重要用途叫做 ”接口演化“。假设有一个类实现了 Java 提供的一个接口，过了 一段时间，Java 为这个接口新加了一个方法。如果没有引入默认方法，那么这个类在新的 JDK 版本下是不能编译通过的。如果将新方法实现为默认方法，就不存在这个问题。

## 同名冲突 / 二义性

如果一个类继承自超类，同时实现了几个接口，且超类和这几个接口中存在同名方法，对这种冲突 Java 的解决规则是：

1. 超类中的方法的优先级高于接口中的方法。

2. 如果是多个接口中的方法存在冲突（至少有一个接口中该方法是默认方法），那么必须在类中覆盖这个方法且必须显式地指出覆盖了哪个接口中的方法。

   ```java
   class Student implements Person, Named{
       public String getName(){
           return Person.super.getName();
       }
   }
   ```

当然，如果没有一个类中的方法被设为默认方法，这被视作没有冲突。此时，子类可以选择给出这个方法的具体实现，或者干脆不给出实现。在后一种情况下，这个类本身就是抽象的。

# lambda 表达式

lambda 表达式的基本形式：参数，箭头，表达式。

```java
(String first, String second) -> {
    if(first.length() - second.length())
        return 0;
    else
        return 1;	// lambda 表达式的返回值类型是不需要指定的
}

// 即使没有参数括号也是不可省的
() -> {
    ...
}

// 如果参数的类型是可以推导的，那么可以省略类型
Comparator<String> comp = (first, second) -> first.length() - second.length();

// 如果只有一个参数，且参数类型可以推导，那么可以省略括号
ActionListener listener = event -> ...;
```

# 内部类

内部类往往与包含它的外部类有比较密切的关系，且和其他内关系不大，因而将这种类定义在其外部类内部，对其他类完全隐藏，可以使程序有更好的封装性，代码也会更简洁。同时，内部类可以方便地访问外部内的私有变量。

值得注意的是，内部类只是 Java 编译器的概念，Java 虚拟机完全不知道存在这个概念。每个内部类都会如一个独立的类一样被编译成一个独立的字节码文件。

## 静态内部类

```java
public class Outer {
    public static class StaticInner {
        ...
}
```

就静态内部类本身而言，其与一个普通的类没有区别，可以定义一切普通类可以定义的变量和方法。

与其他类型的内部类相比，静态内部类与外部类的联系不大。**它可以访问外部类的静态变量和方法，但不可以访问实例变量和方法。**

**被 public 修饰的静态内部类可以被外部使用，使用方式为 “外部类.静态内部类” 的形式。**

在编译时，外部类和静态内部类分别编译为两个独立的类。已经知道，在 Java 中，私有变量是不能被类外部访问的。如何使得静态内部类访问外部类的私有变量呢？Java 的解决方法是：自动为外部类中的私有变量生成一个非私有访问方法，这个方法返回私有静态变量。

一般来说，如果某个类与外部类关系密切，且不依赖于外部类实例，则可以考虑定义为静态内部类。

## 成员内部类

```java
public class Outer {
    public class Inner {
        ...
    }
}
```

除了静态变量和静态方法，成员内部类还可以直接访问外部类的实例变量和实例方法。一般情况下，成员内部类可以直接通过实例变量名、方法名访问外部类的实例变量和实例方法。如果存在重名，可以通过 “外部类.this.xxx” 实现访问。

**成员内部类对象总是与一个外部类对象相连的。**在外部使用时，必须先将创建一个外部类的实例对象，借助这个实例对象创建成员内部类的实例对象，语法是 “外部类对象.new 内部类()”。

```java
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
inner.innerMethod();
```

**在成员内部类中，不可以定义静态变量和方法。**可以这样理解，成员内部类与外部类联系紧密，与外部类的一个实例对象相连，那么成员内部类不应该单独使用，而 static 原意就是为了修饰单独使用内容。二者是矛盾的。即使成员内部类中确实需要静态变量或静态方法，也可以定义在外部类中。

# 异常处理

Java 中所有的异常类都继承自 `Throwable` 。在 `Throwable`下分为两个类。其中，`Error` 描述系统的内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象。应当主要关注 `Exception` 。`Exception` 又分为两类。其中，`RuntimeException` 表示一些由于程序本身有问题导致的异常，`IOException` 表示程序没问题但 I/O 错误导致的异常。

派生于 `Error` 和 `RuntimeException` 的异常叫做非受查异常，其他异常叫做受查异常。

## 声明受查异常

方法应当在首部声明所有可能抛出的异常。

```java
public FileInputStream (String name) throws FileNotFoundException, EOFException{
    ...
}
```

如果在子类中覆盖了超类的一个方法，子类方法中声明的受查异常不能比超类方法中声明的异常更通用。即子类方法中可以抛出更特定的异常，或者根本不抛出任何异常。需要特别说明的是，如果超类方法没有抛出任何受查异常，子类也不能抛出任何受查异常。

## 抛出异常

对于已经存在的异常类，抛出它非常容易：

1. 找到一个合适的异常类
2. 创建这个类的对象
3. 将对象抛出

```java
String readData(Scanner in) throws EOFExcetion{
    ...
    
    while(...){
        if(...){	// EOF encountered
            throw new EOFExcetion();
        }
    }    
        
    ...    
}
```

有时，已有的标准异常不能充分描述问题，这时可以创建自己的异常类。

## 捕获异常

捕获异常使用 try / catch 语句块。

```java
try{
    ...
}
catch(ExceptionType e){
    ...
}
catch(ExceptionType | ExceptionType e){
    ...
}
```

如果在 try 语句块中的任何代码抛出了一个在 catch 子句中说明的异常类，那么程序将跳过 try 语句块的其余代码并将执行 catch 子句中的处理器代码。如果在 try 语句块中的代码没有抛出任何异常，那么程序将跳过 catch子句。如果方法中的任何代码抛出了一个在 catch 子句中没有声明的异常类型，那么这个方法就会立刻退出。

对于异常，通常的处理方法是：对知道如何处理的异常进行捕获，不知道如何处理的代码继续传递。所谓传递，就是只声明不捕获，由方法的调用者处理可能抛出的异常。

## catch 语句抛出异常

catch 子句中可以抛出一个异常，此时， catch 子句中剩余代码将终止执行。

## finally

```java
try{
    ...
}
catch(ExceptionType e){
    ...
}
catch(ExceptionType | ExceptionType e){
    ...
}
finally{
    ...
}
```

无论异常抛出与否，finally 子句中的代码都被执行。通常是一些资源回收代码。

## 解耦合 try / catch 和 try / finally

try 语句可以只有 finally 子句，而没有 catch 子句。

解耦合 try / catch 和 try / finally 可以提高代码清晰度。

```java
// 内层的 try 语句块只有一个职责，就是确保关闭输入流。外层的 try 语句块也只有一个职责，就是确保报告出现的错误。
// 这种设计方式不仅清楚，而且还具有一个功能，就是将会报告 finally 子句中出现的错误。
try{
    try{
        ...
    }
    finally{
        ...
    }
}
catch(...){
    ...
}
```

如果使用 try / finally，且 try 和 finally 中都有 return 语句，则先执行 try 中 return 前的内容，暂时保存需要return 的信息，然后执行 finally 中的内容，最后返回 try 中先前保存的信息。所以，即使 finally 中有 return 语句，返回值也会是 try 中的返回值。

如果 try 和 finally 中都抛出异常，finally 中抛出的异常会覆盖 try 中抛出的异常。这可能会带来问题，因为finally 中抛出的异常是回收资源带来的异常，try 中抛出的异常是逻辑代码抛出的异常，程序员往往更关注后者而非前者。

## 带资源的 try

```java
try(Resource res1; Resource res2){
    ...
}
```

带资源的 try 语句在退出时会自动回收资源。这代替了复杂嵌套的 try / finally 语句。同时，带资源的 try 语句也解决了 finally 中抛出的异常会覆盖 try 中抛出的异常这一问题：原来的异常会重新抛出，而 finally 中抛出的异常会 “被抑制”。如果希望获得 finally 中抛出的异常，可以调用 getSuppressed 方法，它会得到被抑制的异常列表。

一般来说，只要需要关闭资源，就要尽可能使用带资源的 try 语句。

## 异常机制的使用技巧

1. 异常处理不能代替简单的测试，如退栈前检查栈空等。因为与执行简单的测试相比，捕获异常所花费的时间大大超过了前者，所以使用异常的基本规则是：只在异常情况下使用异常机制。
2. 不要过分地细化异常。
3. 合理利用异常层次结构。不要只抛出 RuntimeException 异常，应该寻找更加适当的子类或创建自己的异常类。不要只捕获 Thowable 异常，否则，会使程序代码更难读、更难维护。
4. 不要压制异常。
5. 在检测错误时，“苛刻”要比放任更好。
6. 不要羞于传递异常。

# 断言

断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句将会被自动地移走。Java 中断言的关键字是 assert：

```java
assert 条件;
assert 条件 : 表达式;
```

如果条件的结果是 false，则会抛出 AssertionError 异常，表达式会被传入 AssertionError 的构造器并转换成一个消息字符串。

## 启用或禁用断言

在默认情况下，断言被禁用。可以在运行程序时用 -enableassertions 或 -ea 选项启用断言：

```
java -ea MyApp
```

由于启用或禁用断言是类加载器（class loader）的功能，所以启用或禁用断言时不必重新编译程序。当断言被禁用时，类加载器将跳过断言代码，因此，不会降低程序运行的速度。

## 何时使用断言

- 断言失败是致命的、不可恢复的错误。
- 断言检查只用于开发和测试阶段，用于确定程序的错误位置。

# 日志

当程序运行出错时，程序员常使用 System.out.println 在控制台打印一些信息，以了解程序运行的具体过程。一旦弄清问题是怎么回事，这些代码又要删掉。这样未免过于繁琐。于是出现了日志。

## 基本日志

要生成简单的日志，可以使用全局日志构造器的 info 方法：

```java
Logger.getGlobal().info("...");
```

如果希望取消所有的日志，可以在合适的地方调用 setLevel 方法：

```java
Logger.getGlobal().setLevel(Level.OFF);
```

## 高级日志

可以调用 getLogger 方法自定义日志记录器：

```java
private static final Logger myLogger = Logger.getLogger("com.mycompany.myapp");
```

> 未被任何变量引用的日志记录器可能会被垃圾回收。为了防止这种情况发生，要用一个静态常量存储日志记录器的一个引用。

通常，日志记录器有七个级别：

- SEVERE
- WARNING
- INFO
- CONFIG
- FINE
- FINER
- FINEST

默认情况下只记录前三个级别。可以调用 setLevel 方法设置日志记录器的级别：

```java
logger.setLevel(Level.FINE);
```

此外，Level.ALL 开启所有级别的记录，Level.OFF 关闭所有级别的记录。

## 一些调试技巧

1. 用 System.out.println 或日志了解程序的运行过程。
2. 可以在每个类中放置一个 main 方法，从而对每个类进行单元测试。
3. JUnit 单元测试框架。
4. Throwable 类提供了 printStackTrace 方法可以打印堆栈轨迹。

# 常用基础类

## 包装类

Java的每种基本类型都有一个对应的包装类。一个包装类封装了一个对应基本类型的变量，并提供了一些方法和变量以方便对数据的操作。

### 构造包装类实例对象

每种包装类都有一个静态方法valueOf()，接受基本类型，返回包装类，都有一个xxValue()方法，接受包装类，返回基本类型。

```java
int x = 1;
Integer i = Integer.VauleOf(x);
int y = i.intValue(i);
```

以上的两个过程，将基本类型转换为包装类的过程，一般称为“装箱”，而将包装类型转换为基本类型的过程，则称为“拆箱”。可以看到，封箱、拆箱的过程是比较繁琐的，所以从Java 5开始后引入了自动装箱和拆箱技术。

```java
Integer a = 100;
int b = a;

int a = 100;
Integer b = a;
```

自动装箱、拆箱是Java编译器提供的能力，本质上还是调用对应的valueOf或xxxValue方法。

每种包装类都有构造方法，可以通过new而不是借助已有的基本类型数据构造。

```java
Integer a = new Integer(100);
Boolean b = new Boolean(true);
Double d = new Double(12.345);
Character c = new Character('马');
```

综上所述，既可以用静态的valueOf方法也可以使用new构造包装类实例对象，那么在日常编程中应当使用那种方法呢？一般建议使用valueOf方法。因为new每次都会创建一个新对象，而除了Float和Double外的其他包装类，都会缓存包装类对象，减少需要创建对象的次数，节省空间，提升性能。

值得注意的是，从Java 9开始，这些构造方法已经被标记为过时了，推荐使用静态的valueOf方法。

### 各种包装类的共同点

#### 重写Object类

所有包装类都重写了Object类的一些方法：

```java
boolean equals(Object obj)
int hashCode()
String toString()
```

equals用于判断当前对象和参数传入的对象是否相同。Object类的默认实现是比较地址，对于两个变量，只有这两个变量指向同一个对象时，equals才返回true，它和比较运算符（==）的结果是一样的。然而，一般希望equals反映的是对象间的逻辑相等关系，所以这个默认实现一般是不合适的，子类需要重写该实现。所有包装类都重写了该方法，比较的是其包装的基本类型的值。

hashCode返回一个对象的哈希值。哈希值是一个int类型的数，由对象中一般不变的属性映射得来，用于快速对对象进行区分、分组等。**一个对象的哈希值不能改变，相同对象的哈希值必须一样。不同对象的哈希值一般应不同，但这不是必需的，可以有对象不同但哈希值相同的情况。**由此可知，**对于两个对象，如果equals方法返回true，则hashCode也必须一样。反之不要求，equal方法返回false时，hashCode可以一样，也可以不一样，但应该尽量不一样。**hashCode的默认实现一般是将对象的内存地址转换为整数。应当强调，**子类如果重写了equals方法，也必须重写hashCode。**之所以有这个规定，是因为Java中很多类依赖于这个行为，尤其是容器中的一些类。

所有包装类都重写了hashCode方法。对于Byte、Short、Integer、Character， hashCode的返回值就是其内部值。对于Boolean，hashCode方法重写后为：

```java
public int hashCode() {
    return value ? 1231 : 1237;
}
```

之所以选择这两个数，是因为它们是质数。质数用于哈希时比较好，不容易冲突。

对于Long, hashCode方法重写后为：

```java
public int hashCode() {
    return(int)(value ^ (value >>> 32));
}
```

即高32位与低32位进行位异或操作。

对于Float, hashCode方法重写后为：

```java
public int hashCode() {
	return floatToIntBits(value);
}
```

对于Long, hashCode方法重写后为：

```java
public int hashCode() {
    long bits = doubleToLongBits(value);
    return(int)(bits ^ (bits >>> 32));
}
```

即将double的二进制表示看作long，然后再按long计算hashCode。

每个包装类也都重写了toString方法，返回对象的字符串表示。

#### 实现Comparable接口

每个包装类都实现了Comparable接口。

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

Comparable接口只有一个方法compareTo，当前对象与参数对象进行比较，在小于、等于、大于参数时，应分别返回-1、0、1。

#### 不可变性

包装类都是不可变类。所谓不可变，是指实例对象一旦创建，就没有办法修改了。这是通过如下方式强制实现的：

- 所有包装类都声明为了final，不能被继承。
- 内部基本类型值是私有的，且声明为final。
- 没有定义setter方法。

之所以要定义为不可变类，是因为不可变使得程序更为简单安全，因为不用操心数据被意外改写的可能，可以安全地共享数据，尤其是在多线程的环境下。

## 字符串

字符串操作是计算机程序中最常见的操作之一。Java中处理字符串的主要类是String、StringBuilder、StringBuffer。

### String

#### 创建

String 变量有两种定义方式：

```java
String s = "hello world";

String s = new String("hello world");
```

内存中的有一个共享空间，叫做字符串常量池。它保存了所有的字符串常量，且每个常量只保持一份，为所有使用者共享。在创建字符串时，前一种创建方式会查看常量池中是否存在 hello world 这一字符串。如果存在则直接引用它，否则创建字符串 hello world 并引用它。后者则是在堆中创建一个名为 s 的对象，其 value 是 hello world，然后会检查常量池中是否存在 hello world 这一字符串。如果不存在，则创建字符串 hello world。但无论常量池中是否存在相应的字符串，s 引用的都是堆中的对象。

#### 简单操作

##### 拼接

字符串可以通过 + 或 += 实现拼接。

```java
String s1 = "hello";
s1 += " world";
String s2 = ", java";
System.out.println(s1 + s2);	// hello world, java
```

也可以使用封装的函数。

```java
// 字符串连接，返回当前字符串和参数字符串合并结果
public String concat(String str) 
```

应当指出，concat 只能拼接字符串，+ 除此之外还可以拼接其他的数据类型。

##### 长度

```java
// 判断字符串是否为空
public boolean isEmpty() 
    
// 获取字符串长度
public int length() 
```

##### 子串

```java
// 取子字符串
public String substring(int beginIndex) 
public String substring(int beginIndex, int endIndex)
```

这两个方法的区别在于，前者只给出了取子串的起点，因而子串将从起点一直取到字符串结束；后者从起点取到终点。

至于参数中需要给出的索引下标，一般有两种理解。第一种，可以认为字符串就像一个数字，每个字符有一个自己的下标，substring 在取子串时类似于数学中左闭右开区间，beginIndex 对应的字符会取在子串中，endIndex 对应的字符不会取在子串中。第二种理解，可以认为索引下标是穿插在字符之间的，如下图所示。

<img src="https://raw.githubusercontent.com/landfallbox/Pictures/master/image-20230502162353123.png" alt="image-20230502162353123" style="zoom: 50%;" />

无论从哪种理解出发都会发现 public String substring(int beginIndex) 存在的合理性，因为 public String substring(int beginIndex, int endIndex) 是不能取到最后一个字符的。如果希望取到最后一个字符，则必须使用前一个函数。

##### 子串匹配

```java
// 查找字符，返回第一个找到的索引位置，没找到返回-1
public int indexOf(int ch)
public int lastIndexOf(int ch)
    
// 查找子串，返回第一个找到的索引位置，没找到返回-1
public int indexOf(String str) 
public int lastIndexOf(String str)
```

注意两点：第一，返回的索引值应当这样理解：字符串的每一个字符对应一个索引下标，且下标从 0 开始到 length() - 1 结束。第二，这些函数返回的是第一次匹配上的位置的索引，即使存在多处匹配也是如此。

last 开头的函数表示从后往前找。

##### 包含字符或子串

```java
public boolean contains(CharSequence s)
```

CharSequence 是 Java 中的一个接口，表示 char 的一个可读序列。此接口有几个实现类，分别是CharBuffer、String、StringBuffer、StringBuilder。所以此方法可以用于判断字符串中是否包含某个字符或某个子串。

##### 以何开头 / 结尾

```java
// 判断字符串是否以给定子字符串开头
public boolean startsWith(String prefix) 
    
// 判断字符串是否以给定子字符串结尾
public boolean endsWith(String suffix) 
```

##### 比较

```java
// 与其他字符串比较，看内容是否相同
public boolean equals(Object anObject) 
//忽略大小写比较是否相同
public boolean equalsIgnoreCase(String anotherString) 
```

注意区分比较两个 String 对象时使用 == 和 equals 的区别。== 比较的是引用地址是否相同，equals 比较的是内容是否相同。

##### 大小写转换

```java
// 所有字符转换为大写字符，返回新字符串，原字符串不变
public String toUpperCase() 
    
//所有字符转换为小写字符，返回新字符串，原字符串不变
public String toLowerCase() 
```

##### 替换字符

```java
//字符串替换，替换单个字符
public String replace(char oldChar, char newChar) 

//字符串替换，替换字符序列，返回新字符串，原字符串不变
public String replace(CharSequence target, CharSequence replacement)
    
replaceFirst(String regex, String replacement)
replaceAll(String regex, String replacement)
```

replace 和 replaceAll 都会替换全部符合条件的字符或字符串，replaceFirst 则只替换第一个阿玛尼组条件的字符或字符串。

##### 删掉空格

```java
// 删掉开头和结尾的空格，返回新字符串，原字符串不变
public String trim() 
```

##### 分割字符串

```java
// 以正则表达式匹配的字符分割字符串，返回分割后的字符串数组
public String[] split(String regex) 
```

#### 不可变性

与包装类类似，String 类也是不可变类，即对象一旦创建，就没有办法修改了。String 类也声明为了final，不能被继承，内部 char 数组 value 也是 final 的，初始化后就不能再变了。这种做法的初衷与将包装类设计为不可变类似，使得程序更为简单、安全、容易理解。

由于 String 对象是不可修改的，所以 String 类中虽然提供了很多看似修改了字符串内容的方法，其本质都是通过创建新的 String 对象来实现的，原来的 String 对象不会被修改。正因如此，频繁修改字符串将降低程序的性能。为此，Java 提供了 StringBuilder 和 StringBuffer。

### StringBuilder / StringBuffer

StringBuilder 和 StringBuffer 在实现上几乎一模一样，唯一的不同就在于 StringBuffer 类是线程安全的，而 StringBuilder 类不是。由于字符串对象及操作大部分情况下不存在线程安全问题，所以 StringBuilder 类使用得更多些。

#### 创建

初始化后的 StringBuilder 其中的内容是空的，需要使用 append 方法向其中添加内容。希望获得 StringBuilder 中包含的内容时可以使用 toString 方法。

```java
StringBuilder sb = new StringBuilder();
sb.append("hello");
sb.append(", world");
System.out.println(sb.toString());
```

# 文件

## 一些基础知识和常识

所有文件本质上都是0和1组成的二进制文件，但为了便于理解和处理，存在文件类型的概念。文件类型通常以扩展名的形式体现，可以粗略分为两种：文本文件，二进制文件。对于文本文件，需要注意其编码方式。文本文件中都是可打印字符。所谓编码，就是字符和二进制之间的映射规则。

文件存储在硬盘上，应用用到某个文件时需要先读到操作系统的内核，再读到应用对应的内存空间。由于硬盘的读写速度比内存慢很多，为了提升操作文件的效率，一种常见的策略是使用缓冲区。读文件时除了读取应用要求的内容外，如果预感到应用可能还会继续往下读，则读取比要求的更多的内容。下次应用读取文件时，如果缓冲区有要读的内容，则可以直接从缓冲区读到应用对应的内存中，从而避免访问操作系统和硬盘。写文件时，先把要写的内容存在缓冲区中，再一次性把缓冲区的内容写入硬盘。

## Java中的基本概念

### 流

Java中视文件为输入输出的一种，而对于所有的IO，Java使用一个统一的概念对其处理：流。流分为输入流和输出流。

### 装饰器（设计模式）

基本的流以字节为单位读写文件，没有缓冲区，使用不方便。为解决这一问题，Java使用了装饰器设计模式，即定义很多装饰类，它们对基本的流实现扩展，针对某个方面增加基本流没有的功能，方便程序员使用。

装饰类很多，基类只有两个：FilterInputStram和FilterOutputStram。它们有很多子类：

- 对流起缓冲作用的是BufferedInputStrean和BufferedOutputStrean。
- 按8种基本类型和字符串对流进行读写的是DataInputStream和DataOutputStream。
- 对流进行压缩和解压缩的子类有GZIPInputStream、ZipInputStream、GZIPOutput-Stream和ZipOutputStream。
- 将基本类型、对象输出为其字符串表示的子类是PrintStream。

### Reader / Writter

以InputStream/OutputStream为基类的流只能以二进制形式处理数据，不能够方便地处理文本文件，没有编码的概念。为解决这个问题，Java给出了能够方便地按字符处理文本数据的基类：Reader和Writer，它们也有很多子类：

- 读写文件的是FileReader和FileWriter。
- 起缓冲装饰的是BufferedReader和BufferedWriter。
- 将字符数组包装为Reader/Writer的是CharArrayReader和CharArrayWriter。
- 将字符串包装为Reader/Writer的是StringReader和StringWriter。
- 将InputStream/OutputStream转换为Reader/Writer的是InputStreamReader和OutputStreamWriter。
- 将基本类型、对象输出为其字符串表示的是PrintWriter。

### NIO

上述的类基本都位于包java.io下，Java中还有一个关于IO操作的包java.nio。NIO表示New IO，代表一种不同的看待IO的方式，它有缓冲区和通道的概念。利用缓冲区和通道往往可以达成和流类似的目的，不过，它们更接近操作系统的概念，某些操作的性能也更高。此外，NIO还支持一些比较底层的功能，如内存映射文件、文件加锁、自定义文件系统、非阻塞式IO、异步IO等。

### 序列化和反序列化

简单来说，序列化就是将内存中的Java对象持久保存到一个流中，反序列化就是从流中恢复Java对象到内存。序列化和反序列化主要有两个用处：一是对象状态持久化，二是网络远程调用，用于传递和返回对象。

Java主要通过接口Serializable和类ObjectInputStream、ObjectOutputStream提供对序列化的支持。不过，Java的默认序列化有一些缺点，比如，序列化后的形式比较大、浪费空间，序列化/反序列化的性能也比较低，更重要的问题是，它是Java特有的技术，不能与其他语言交互。

前几年最为流行的描述结构性数据的语言和格式是XML。它易于阅读和编辑，且可以方便地与其他语言交互，Java对它提供了支持。但XML强调格式化导致其相对笨重，近几年逐渐流行的更轻量的数据交换格式是JSON。JSON也具备易于阅读和编辑、可以方便地与其他语言交互等XML的优点，Java对它也提供了支持。

## 二进制文件，字节流

Java中处理二进制文件的流包括：

- InputStream/OutputStream：这是基类，下面的这些类都继承自它们。它们是抽象类。
-  FileInputStream/FileOutputStream：输入源和输出目标是文件的流。
-  ByteArrayInputStream/ByteArrayOutputStream：输入源和输出目标是字节数组的流。
- DataInputStream/DataOutputStream：装饰类，按基本类型和字符串而非只是字节读写流。
- BufferedInputStream/BufferedOutputStream：装饰类，对输入输出流提供缓冲功能。

### InputStream

InputStream类包含一些基本方法：

```java
public abstract int read() throws IOException;
public int read(byte b[]) throws IOException;
public int read(byte b[], int off, int len) throws IOException;
public void close() throws IOException;
```

无参read方法从流中读取下一个字节，返回类型为int，但取值为0～255。当读到流结尾的时候，返回值为-1。如果流中没有数据，此方法会阻塞直到数据到来、流关闭或异常出现。异常出现时，read方法抛出异常IOException。这是一个受检异常，调用者必须进行处理。可以看到，read是一个抽象方法，子类负责其具体实现。

第二个read方法将读入的字节放入参数数组b中，第一个字节存入b[0]，第二个存入b[1]，以此类推。一次最多读入的字节个数为数组b的长度，但实际读入的个数可能小于数组长度。返回值为实际读入的字节个数。如果刚开始读取时已到流结尾，则返回-1。否则，只要数组长度大于0，该方法都会尽力至少读取一个字节，如果流中一个字节都没有，它会阻塞，异常出现时也是抛出IOException。该方法不是抽象方法，InputStream有一个默认实现，主要就是循环调用读一个字节的read方法，但子类如FileInputStream往往会提供更为高效的实现。

第三个read方法是更为通用的重载，它将读入的第一个字节放入b[off]，最多读取len个字节。其实，read(byte b[])就是调用了该方法：

```java
public int read(byte b[]) throws IOException {
    return read(b, 0, b.length);
}
```

应当强调，不管read方法是否抛出了异常，都应该调用close方法关闭文件，所以close方法通常应该放在finally语句内。close方法自己可能也会抛出IOException，但通常可以捕获并忽略。

InputStream类中还有一些特殊方法：

```JAVA
public long skip(long n) throws IOException;
public int available() throws IOException;
public synchronized void mark(int readlimit);
public boolean markSupported();
public synchronized void reset() throws IOException;
```

skip的默认实现是跳过输入流中n个字节。由于输入流中剩余的字节个数可能不到n，所以返回值为实际略过的字节个数。子类往往会重写此方法，提供更为高效的实现。值得一提的是，在处理数据时，对于不感兴趣的部分，skip往往比读取然后扔掉的效率要高。

available返回下一次不需要阻塞就能读取到的大概字节个数。InputStream的默认实现是返回0，子类会根据具体情况返回适当的值。在文件读写中，这个方法一般没什么用，但在从网络读取数据时，可以根据该方法的返回值在网络有足够数据时才读，以避免阻塞。

一般情况下流的读取都是一次性的，且只能从前向后，但存在这样的情况：希望先看一眼后面的内容是什么再决定怎么读，因而出现了 `mark`、`reset` 方法。具体实现方式是先使用 `mark` 方法将当前位置标记下来，在读取了一些字节后，调用 `reset` 方法可以从标记位置重新读取流中的内容。然而，能够重复读取不代表能够回到任意的标记位置。`mark` 方法有一个参数 `readLimit` ，表示在设置了标记后，能够继续往后读的最多字节数。如果超过了限制，标记会失效。之所以要这样设置，是因为重读本质上是将从标记位置开始的字节保存起来，而保存消耗的内存不能无限大，必须给出一个上限 `readLimit` 。不过，不是所有流都支持 `mark`、`reset` 方法，是否支持可以通过 `markSupported` 的返回值进行判断。`InpuStream` 的默认实现是不支持，`FileInputStream` 也不直接支持，但 `BufferedInputStream` 和 `ByteArrayInputStream` 都支持。

### OutpuStream

OutputStream中的基本方法是write，它的几个重载和InputStream的read方法极类似，可以说是一模一样，区别是write是写，read是读。

此外，OutputStream中还有其他方法：

```java
public void flush() throws IOException;
public void close() throws IOException;
```

flush负责将已写入缓冲区且没有写入硬盘的内容写进文件，但由于基类OutputStream没有缓冲，所以flush方法代码默认为空。

close方法一般会首先调用flush方法，然后再释放流占用的系统资源。同InputStream一样，close方法一般应该放在finally语句内。

### FileOutputStream

FileOutputStream有多个构造方法，其中两个如下所示：

```java
public FileOutputStream(File file, boolean append) throws FileNotFoundException
public FileOutputStream(String name) throws FileNotFoundException
```

其中，File类型的参数file和字符串的类型的参数name都表示文件路径。路径可以是绝对路径，也可以是相对路径。如果文件已存在，append参数指定是追加还是覆盖，true表示追加， false表示覆盖。第二个构造方法没有append参数，默认是覆盖。

### FileInputStream

FileInputStream的主要构造函数为：

```java
public FileInputStream(String name) throws FileNotFoundException;
public FileInputStream(File file) throws FileNotFoundException;
```

其参数与FileOutputStream的参数含义相同，但要求必须是一个文件而不是目录。

可以看出，即使只是按二进制字节读写流，Java也包括了很多的类。虽然很灵活，但对于一些简单的需求，却需要写很多代码。实际开发中，经常需要将一些常用功能进行封装，提供更为简单的接口。此外，Apache有一个类库Commons IO，里面提供了很多简单易用的方法，实际开发中，可以考虑使用。

### ByteArrayOutputStream

ByteArrayOutputStream的输出目标是一个byte数组，它的长度是根据数据内容动态扩展的，有两个构造方法：

```java
public ByteArrayOutputStream();
public ByteArrayOutputStream(int size);
```

size指定初始的数组大小。如果没有指定，则长度为32。在调用write方法的过程中，如果数组大小不够，会进行扩展。扩展策略是指数扩展，每次至少增加一倍。

ByteArrayOutputStream提供了一些方法以方便地将数据转换为字节数组或字符串：

```java
public synchronized byte[] toByteArray();
public synchronized String toString();
public synchronized String toString(String charsetName);
```

### ByteArrayInputStream

ByteArrayInputStream将byte数组包装为一个输入流，是一种适配器模式，它的构造方法有：

```java
public ByteArrayInputStream(byte buf[]);
public ByteArrayInputStream(byte buf[], int offset, int length);
```

第二个方法的参数指定从offset开始读取length个数据。ByteArrayInputStream的所有数据都在内存，支持mark、reset重复读取。

为什么要将byte数组转换为InputStream呢？这与容器类中要将数组、单个元素转换为容器接口的原因是类似的，有很多代码是以InputStream、OutputSteam为参数构建的，它们构成了一个协作体系，将byte数组转换为InputStream可以方便地参与这种体系，复用代码。

### DataOutputStream

DataOutputStream是FilterOutputStream的子类，FilterOutputStream是OutputStream的子类。FilterOutputStream的构造方法是：

```java
public FilterOutputStream(OutputStream out)
```

它接受一个已有的OutputStream，基本上代理了所有操作。

DataOutputStream继承自FilterOutputStream，实现了DataOutput接口，可以以各种基本类型和字符串写入数据，部分方法如下：

```java
void writeBoolean(boolean v) throws IOException;
void writeInt(int v) throws IOException;
void writeUTF(String s) throws IOException;
```

### DataInputStream

DataInputStream与DataOutputStream类似，只是write变成read。

### BufferedInputStream、BufferedOutputStream

FileInputStream、FileOutputStream是没有缓冲的，按单个字节读写时性能比较低。虽然可以按字节数组读取以提高性能，但有时必须要按字节读写，解决方法是将文件流包装到缓冲流中。

BufferedInputStream内部有个字节数组作为缓冲区，读取时，先从这个缓冲区读，缓冲区读完了再调用包装的流读，它的构造方法有两个：

```java
public BufferedInputStream(InputStream in);
public BufferedInputStream(InputStream in, int size);
```

size表示缓冲区大小，如果没有，默认值为8192。BufferedInputStream也支持mark、reset，可以重复读取。

在使用FileInputStream、FileOutputStream时，应该几乎总是在它的外面包上对应的缓冲类，如下所示：

```java
InputStream input = new BufferedInputStream(new FileInputStream("hello.txt"));
OutputStream output = new BufferedOutputStream(new FileOutputStream("hello.txt"));
```

## 文本文件，字符流

由于字节流没有编码的概念，不能按行处理，所以使用它处理文本文件是不太方便的，更合适的方式是使用字符流。

Java中的主要字符流有：

- Reader/Writer：字符流的基类，它们是抽象类。
- InputStreamReader/OutputStreamWriter：适配器类，将字节流转换为字符流。
- FileReader/FileWriter：输入源和输出目标是文件的字符流。
- CharArrayReader/CharArrayWriter：输入源和输出目标是char数组的字符流。
- StringReader/StringWriter：输入源和输出目标是String的字符流。
- BufferedReader/BufferedWriter：装饰类，对输入/输出流提供缓冲，以及按行读写功能。
- PrintWriter：装饰类，可将基本类型和对象转换为其字符串形式输出的类。

## 序列化

### 默认序列化

如果希望把对象保存到文件，前面已经看到，可以使用DataOutputStream。相应地，读文件可以使用DataInputStream。然而，使用它们需要逐个处理对象中的每个字段，这样比较烦琐。存在一种更简单的机制：序列化。

要让一个类支持序列化，只需要让这个类实现接口java.io.Serializable。Serializable没有定义任何方法，只是一个标记接口。声明实现了Serializable接口后，保存或读取类对象就可以使用ObjectOutputStream和ObjectInputStream。

ObjectOutputStream是OutputStream的子类，但实现了ObjectOutput接口。ObjectOutput是DataOutput的子接口，增加了一个能够将对象obj转化为字节写到流中的方法：

```java
public void writeObject(Object obj) throws IOException
```

与之类似，ObjectInputStream是InputStream的子类，实现了ObjectInput接口。ObjectInput是DataInput的子接口，增加了一个能够从流中读取字节转化为一个对象的方法：

```java
public Object readObject() throws ClassNotFoundException, IOException
```

以学生类Student为例看上述内容的使用：

```java
public static void writeStudents(List<Student> students) throws IOException {
    ObjectOutputStream out = new ObjectOutputStream(
        new BufferedOutputStream(new FileOutputStream("students.dat")));
    
    try {
        out.writeInt(students.size());
        
        for(Student s : students) {
            out.writeObject(s);
        }
    } finally {
        out.close();
    }
}

public static List<Student> readStudents() throws IOException, ClassNotFoundException {
    ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(
        new FileInputStream("students.dat")));
    
    try {
        int size = in.readInt();
        List<Student> list = new ArrayList<>(size);
        
        for(int i = 0; i < size; i++) {
            list.add((Student) in.readObject());
        }
        
        return list;
    } finally {
        in.close();
    }
}
```

而如果List也实现了Serializable，则上述代码还可以进一步简化：

```java
public static void writeStudents(List<Student> students) throws IOException {
    ObjectOutputStream out = new ObjectOutputStream(
        new BufferedOutputStream(new FileOutputStream("students.dat")));
    try {
        out.writeObject(students);
    } finally {
        out.close();
    }
}
public static List<Student> readStudents() throws IOException,
ClassNotFoundException {
    ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(
        new FileInputStream("students.dat")));
    try {
        return (List<Student>) in.readObject();
    } finally {
        in.close();
    }
}
```

事实上，先前介绍的String、Date、Double、ArrayList、LinkedList、HashMap、TreeMap等都满足这一条件，实现了Serializable接口。

### 定制序列化

默认序列化很强大，但它会将一个类实例的全部内容序列化，有些时候这并不是我们想要的。譬如，一些字段可能和内存、时间有关，将这些字段序列化再反序列化是没有意义的。还有，有些类中的字段表示的是类的实现细节，而非逻辑信息，将这些信息序列化会破坏类的封装。为此，Java提供了多种定制序列化的机制，主要是两种：一种是transient关键字，另外一种是实现writeObject和readObject方法。

#### transient

将字段声明为transient，默认序列化机制将忽略该字段，不会进行保存和恢复。

# 并发

## 线程基础

**每个线程表示一条单独的执行流，有自己的程序计数器和栈。同进程的多个线程间共享内存，它们访问和操作相同的对象。**

### 创建线程

Java 中使用一个继承于 Thread 的类表示一个线程。其中，run 方法中的内容是该线程执行的代码。

```java
public class HelloThread extends Thread {
    @Override
    public void run() {
        System.out.println("hello");
    }
}
```

### 启动线程

线程创建后不会自动执行，需要启动它。

```java
public static void main(String[] args) {
    Thread thread = new HelloThread();
    thread.start();
}
```

如果不通过 Thread 对象调用 start 方法来启动一个线程，而是直接调用 run 方法，其中的代码会一样执行，执行效果也相同。可以使用以下的方式知道当前执行的线程是哪个线程：

```java
@Override
public void run() {
    System.out.println("thread name: "+ Thread.currentThread().getName());
    System.out.println("hello");
}
```

### Runnable 接口

因为 Java 只允许单继承，如果某给类已经有了超类，就得通过实现 Runnable 接口来实现线程。

Runnable 接口定义如下：

```java
public interface Runnable {
    public abstract void run();
}
```

实现 Runnable 接口和继承 Thread 类是类似的。

```java
public class HelloRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("hello");
    }
}
```

当然也是要启动的。

```java
public static void main(String[] args) {
    Thread helloThread = new Thread(new HelloRunnable());
    helloThread.start();
}
```

### 线程的基本属性和方法

#### id

id 是一个自增的整数。每有一个线程系统就会使它加一。

#### name

name 的默认值是 Thread-id。name 可以在 Thread 的构造器中指定，也可以通过 setName 方法设置。给线程设置名字的目的是为了方便调试。

#### priority

priority 是优先级。Java 中优先级从一到十，默认是五。它有相应的 getter 和 setter。由于 Java 的优先级与操作系统的优先级不是一一对应的，而且优先级对于操作系统只是建议、提示的作用而非强制的，所以编程时不要过于依赖优先级。

#### state

state 表示状态。它只有 getter 没有 setter。它的 getter 的返回值是一个枚举类型：

```java
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```

其中，没调用 start 时线程的状态是 NEW，调用 start 后且没有阻塞时的状态是 RUNNABLE（未必在执行代码，可以在等待操作系统分配时间片），线程运行结束后的状态是 TERMINATED。

#### sleep 方法

调用 sleep 会让当前线程睡眠一段时间，单位是毫秒。

#### yield 方法

调用 yield 会告诉操作系统的调度器当前线程不着急执行，可以优先执行其他线程。但这对调度器而言也只是建议，不是强制的。

#### join 方法

有可能子线程还没有结束，父线程已经执行完了。如果希望父线程等待子线程结束再结束，可以在父线程中使用 join 方法。注意，join 方法的作用是使执行者进入调用者的等待队列。在下例中，main 线程是执行者，thread 线程是调用者，所以 main 线程会等待 thread 线程执行结束才会继续执行。

```java
public static void main(String[] args) throws InterruptedException {
    Thread thread = new HelloThread();
    thread.start();
    thread.join();
}
```

## 引入线程机制的好处

1. 充分利用多CPU的计算能力。单线程只能利用一个CPU，使用多线程可以利用多CPU的计算能力。
2. 充分利用硬件资源。CPU 和硬盘、网络等资源是可以同时工作的：一个线程在等待网络 IO 的同时，另一个线程完全可以利用 CPU。对于多个独立的网络请求，完全可以使用多个线程同时请求。
3. 在用户界面（GUI）应用程序中，保持程序的响应性。界面和后台任务通常是不同的线程，否则，如果所有事情都是一个线程来执行，当执行一个很慢的任务时，整个界面将停止响应，也无法取消该任务。
4. 简化建模及 IO 处理。比如，在服务器应用程序中，对每个用户请求使用一个单独的线程进行处理，相比使用一个线程，处理来自各种用户的各种请求，以及各种网络和文件 IO 事件，建模和编写程序要容易得多。

## 多线程的问题

多线程可能带来竞态条件和内存可见性问题。

竞态条件就是多线程的互斥同步问题。

在计算机系统中，除了内存，数据还会被缓存在CPU的寄存器以及各级缓存中，当访问一个变量时，可能直接从寄存器或CPU缓存中获取，而不一定到内存中去取，当修改一个变量时，也可能是先写到缓存中，稍后才会同步更新到内存中。在多线程的程序中，，这会造成严重的问题：**一个线程对内存的修改，另一个线程看不到。有可能因为修改没有及时同步到内存，有可能因为线程根本就没从内存读。**

应当明确，由于每个线程需要单独的数据结构、栈、程序计数器等资源，所以线程本身是有成本的。此外，线程的创建、调度、切换也需要消耗操作系统的资源。并不是线程越多越好。

一般来说，如果线程中实际执行的事情比较多，这些成本是可以接受的。但如果线程中只是简单任务，那么上述成本就不得不被考虑。

另外，如果执行的任务都是CPU密集型的，那创建超过CPU数量的线程就是没有必要的，并不会加快程序的执行。

## synchronized 关键字

Java 用 synchronized 关键字解决竞态条件和内存可见性问题。

### 竞态条件

#### synchronized 修饰实例方法

```java
public class Counter {
    private int count;
    public synchronized void incr(){
        count ++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

被 synchronized 修饰的方法在被多个线程调用时，如果多线程操作的是同一个实例对象，那么会形成互斥访问。如果不是同一个实例对象，那么多线程并行执行。

多线程互斥执行方法的简化过程大致是：

1. 线程尝试获得锁。如果能够获得锁，继续下一步，否则加入等待队列，线程阻塞并等待唤醒。
2. 线程被唤醒，获得锁，执行方法中的代码。
3. 线程释放锁。如果等待队列上有等待的线程，从中取一个并唤醒。对于多个等待的线程，唤醒哪一个是不一定的，不保证公平性。

应当强调，**synchronized 保护的是对象而非代码**。只要访问的是同一个对象的 synchronized 方法，即使是不同的代码，也会形成互斥访问。以上面的代码为例，不只同一个实例对象的 incr 不能并发执行，同一个实例对象的 incr 和 getCount 也是不能并发执行的。

此外，如果类中存在没有被 synchronized 修饰的方法，那么即使此方法读写程序员希望保护的变量，它也可以和被 synchronized 修饰的方法并发执行。因此，**一般在保护变量时，需要在所有访问该变量的方法上加上synchronized。**

#### synchronized 修饰静态方法

synchronized 修饰静态方法时的作用和修饰实例方法时的作用是一致的。

当 synchronized 修饰实例方法时，它保护的对象是当前的实例对象 this。当 synchronized 修饰静态方法时，它保护的对象是类对象。由于 synchronized 修饰实例方法和修饰静态方法时保护的对象不同，所以如果一个类中既有实例方法，也有静态方法，且有两个线程，一个希望执行 synchronized 修饰的实例方法，一个希望执行 synchronized 修饰的静态方法，这两个线程是可以并发执行的。

#### synchronized 包装代码块

基本格式为：

```java
synchronized(...){
    ...
}
```

其中，圆括号中是 synchronized 保护的对象。

#### 可重入性

synchronized 是可重入的，即当某个线程获得锁后，其他调用这个锁的线程会被阻塞，但当前线程可以调用当前对象其他被 synchronized 修饰的代码。之前所以要对此作说明，是因为并不是所有的锁都是可重入的。

**可重入是通过记录锁的持有线程和持有数量来实现的**。当调用被 synchronized 保护的代码时，检查对象是否已被锁。如果是，再检查是否被当前线程锁定。如果是，增加持有数量。如果不是被当前线程锁定，线程加入等待队列。当释放锁时，减少持有数量，当数量变为0时才释放整个锁。

### 内存可见性

synchronized 除了可以将被修饰的代码变成原子操作，从而避免竞态条件。除此以外，对于本身就是原子操作的代码，也可以用 synchronized 修饰以解决内存可见性的问题。

对于被 synchronized 修饰的代码，线程在释放锁时，所有写入都会写回内存。而获得锁后，都会从内存中读最新数据。

但如果只是为了保证内存可见性而使用 synchronized 成本有点高，有一种更轻量的方式：volatile 修饰符。

```java
public class Switcher {
    private volatile boolean on;
    
    public boolean isOn() {
        return on;
    }
    
    public void setOn(boolean on) {
        this.on = on;
    }
}
```

加了 volatile 之后，Java 会在操作对应变量时插入特殊的指令，保证读写到内存最新值，而非缓存的值。

### 死锁

无论使用 synchronized 或者其他锁都要注意避免死锁。为此，应该尽量避免在持有一个锁的同时去申请另一个锁。如果确实需要多个锁，所有代码都应该按照相同的顺序去申请锁。不过，在复杂项目中这种约定很难实现。

如果不能形成约定，使所有线程申请锁的顺序相同，还可以使用显式锁接口。它支持尝试获取锁（tryLock）和带时间限制的获取锁方法。实现此接口的方法可以在获取不到锁的时候释放已经持有的锁，然后再次尝试获取锁或干脆放弃，以避免死锁。

## 线程协作

Java 中的线程协作都是基于 wait / notify 机制实现的。

### wait / notify

在 Object 类中定义了一些线程协作的基本方法，主要分为两类：wait 和 notify。

wait 方法主要有两个：

```java
public final void wait() throws InterruptedException;
public final native void wait(long timeout) throws InterruptedException;
```

第二个方法的参数表示等待时间，单位是毫秒。参数如果是 0，则表示无限等待。第一个方法无参，表示无限等待，相当于 wait(0)。等待期间都可以被中断，如果被中断，会抛出 InterruptedException。

线程调用 wait 后阻塞并进入对象的条件队列，直到它等待的某个条件改变。这个条件往往只能由其他线程改变。条件改变时，其他线程应当调用 notify 方法从条件队列中选择一个线程移除出条件队列并将它唤醒。

notify 方法主要有两个：

```java
public final native void notify();
public final native void notifyAll();
```

区别在于 notify 唤醒一个线程，notifyAll 唤醒全部线程。

应当注意，**wait / notify 方法只能在 synchronized 代码块内被调用**，如果调用 wait / notify 方法时，当前线程没有持有对象锁，会抛出异常 java.lang.IllegalMonitor-StateException。

奇怪的是，wait 和 notify 都在 synchronized 代码块内，一个线程调用 wait 时，另一个线程是不可以调用同一对象的 notify 的，但此处却做到了。这是因为虽然**当调用 wait 时，线程会释放对象锁。**

wait 方法的具体执行过程是：

1. 当前线程进入条件等待队列，释放对象锁，阻塞等待，线程状态变为WAITING或TIMED_WAITING。
2. 等待时间到或被其他线程调用 notify / notifyAll 从条件队列中移除，此时线程被唤醒，但需要重新竞争对象锁。如果能够获得锁，线程状态变为 RUNNABLE，并从 wait 调用中返回。否则，该线程加入对象锁等待队列，线程状态变为 BLOCKED，只有在获得锁后才会从 wait 调用中返回。

然而，线程从 wait 调用中返回后，其等待的条件未必能被满足，它需要重新检查其等待的条件。常见的代码形式上一般为：

```java
synchronized (obj) {
    while(条件不成立){
        obj.wait();
    }
    //执行条件满足后的操作
   	...   
}
```

当线程调用 notify 时，不会释放当前线程的对象锁，所以，只有在包含 notify 的 synchronized 代码块执行结束后，等待的线程才会从 wait 调用中返回。

简单总结一下，wait / notify 被不同的线程调用，线程间共享相同的锁和条件等待队列，围绕一个共享的条件变量进行协作。因此，在设计多线程协作时，需要想清楚协作的共享变量和条件是什么，这是协作的核心。

### 多线程协作

#### 生产者 / 消费者

生产者 / 消费者问题描述的场景大约是：生产者往队列上放数据，如果满了就 wait，而消费者从队列上取数据，如果队列为空也 wait。可以清楚地看到，协作的共享变量是队列。

应当注意，**生产者向队列上放数据的方法和消费者从队列上取数据的方法都应当调用 notifyAll 而不是 notify**。因为由于生产者和消费者的共享变量是同一个队列实例对象，所以它们共用条件等待队列。如果调用 notify，那么从条件等待队列中唤醒的既可能是生产者进程，也可能是消费者进程。如果唤醒的是同类进程，就不能完成线程协作。

可以看到，只有一个条件等待队列使对等待条件的分析变得复杂，这是 wait / notify 机制的局限性。

#### 同时开始

多线程同时开始可与跑步比赛类比，主线程就是裁判，多个子线程就是运动员。主线程与子线程协作的共享变量是开始信号。

多线程共享一个信号，这个信号表示是否开始。每个子线程调用 wait 等待开始信号，主线程发出开始信号并调用 notifyAll 通知所有子线程，从而实现同时开始。

#### 同时结束

之前看到，调用 thread.join() 的线程会等待 thread 线程结束，其实 join 本质上就是调用了 wait。

```java
while (isAlive()) {
    wait(0);
}
```

只要线程还活着，isAlive() 就会返回 true，join 就一直等待。当线程运行结束的时候，Java 系统调用 notifyAll 通知调用者。

显而易见的，如果希望主线程和子线程同时结束，必须为每个子线程调用 join 方法，这未免有点繁琐了。其实，可以通过共享变量实现类似的效果。

这种实现多线程同时结束的方式是：多线程共享一个数，这个数表示未完成的线程个数。每个子线程结束后都将该值减一，当减为0时调用 notifyAll。

其实，上述方式具有一定的通用性，不仅可以实现同时结束，也可以实现同时开始。

#### 异步结果

常见的主线程创建子线程的情况是：希望利用子线程完成一些任务，同时主线程可以做其他的事。当子线程执行完毕，主线程得到执行结果，继续执行中止的任务。然而，如果主线程处理的任务过多或者很复杂，需要不断创建子线程，程序员将一直通过 new Thread 创建线程，这是很繁琐的。可以将上述过程封装起来供使用者调用。

#### 集合点

以并行迭代计算为例解释集合点描述的多线程协作场景：在并行迭代计算中，每个线程负责一部分计算，然后等待其他线程完成，所有线程到齐后，交换数据和计算结果，再进行下一次迭代。

在集合点模型下，协作的共享变量是一个数。这个数表示未到集合点的线程个数，初始值为子线程个数，每个线程到达集合点后将该值减一。如果不为0，表示还有别的线程未到，进行等待；如果变为0，表示自己是最后一个到的，调用 notifyAll 唤醒所有线程。

应当说明，对上述所有多线程协作场景 Java 都已经创建了一些框架、工具供程序员使用。在具体的程序开发中应当尽量使用现有的类，避免重复造轮子。

## 线程中断

一般情况下，线程经过 start 启动，执行 run 方法，完成后退出。但存在一些情况需要手动将线程关闭：

- 很多线程本身是死循环，在适当的时候应当手动将它们关闭。譬如生产者 / 消费者，它们都不停地放内容、取内容，当停止程序时应当 “优雅” 地将它们也停止。
- 在一些情况下，可能执行到一半用户就希望放弃任务、停止执行。如下载文件。
- 在一些情况下，如果任务执行时间过长，应当停止执行。如向服务器请求某个结果。
- 有时，可能使用多个线程执行同一个任务。如果其中某个线程已经得到执行结果，除它本身正常结束外，还应当通知别的线程终止执行。

### 中断机制

Thread 类中存在 stop 方法，它本可以用于停止线程，但现在此方法已被标记为过时，应当避免使用。

当前，停止进程的方式主要是中断。中断并不是强迫终止一个线程，而是给线程传递一个取消信号，由线程来决定如何以及何时退出。它本质上一种协作机制。

Thread 类定义了如下方法来中断线程：

```java
public boolean isInterrupted();
public void interrupt();
public static boolean interrupted();
```

其中，isInterrupted() 和 interrupt() 是实例方法，调用它们需要通过线程对象；interrupted() 是静态方法，实际会调用 Thread. currentThread() 操作当前线程。

在 Java 中，每个线程都有一个标志位，用于表示该线程是否被中断了。isInterrupted 返回的就是该标志位的信息。interrupt 会中断调用此方法的线程。interrupted 既中断线程，又返回标志位信息。

>显而易见，如果连续两次调用 interrupted，两次的返回结果一般是不同的，除非同时又发生了一次中断。

### 中断对线程的影响

中断影响线程的状态和正在进行的 I/O 操作。这里主要讨论对线程状态的影响。

#### RUNNABLE

被中断时，如果线程处于运行中，且没有 I/O 操作，那么线程表示是否中断的标志位将被置 True，其余没有影响。因而，对于可能需要被中断的线程，例如主要代码体是死循环的线程，其 run 方法应当在每次循环的开始处检查中断标志位的信息，从而实现线程中断。

#### WAITING / TIMED_WAITING

线程调用 join / wait / sleep 方法会进入 WAITING 或 TIMED_WAITING 状态，此时如果线程被中断，线程将抛出异常 InterruptedException，且中断标志位将被清空，即置 False。

值得注意的是，InterruptedException 是一个受检异常，线程必须进行处理。捕获到 InterruptedException 时，通常表示希望结束该线程。大致有两种处理方式：

1. 向上传递该异常，这使得该方法也变成了一个可中断的方法，需要调用者进行处理。
2. 有些情况，不能向上传递异常。比如 Thread 的 run 方法，它的声明是固定的，不能抛出任何受检异常。这时，应该捕获异常，进行合适的清理操作。清理后，一般应该调用 Thread.interrupt 方法置中断标志位为 True，使得其他代码有办法知道它发生了中断。

#### BLOCKED

线程处于 BLOCKED 状态，表示在等待锁。此时如果线程被中断，那么线程表示是否中断的标志位将被置 True，线程依然会处于 BLOCKED 状态。也就是说，线程依然在等待锁，而不会因为中断从锁等待队列中出来，更不会结束。

在使用 synchronized 关键字获取锁的过程中不响应中断请求，这是 synchronized 的局限性。如果希望避免这一问题，可以使用显式锁。

#### NEW / TERMINATE

如果线程尚未启动（NEW），或者已经结束（TERMINATED），则调用 interrupt() 对它没有任何效果，中断标志位也没有任何改变

### 正确地取消 / 关闭线程

前面已经提到，interrupt 方法不一定会真正 “中断” 线程。它只是一种协作机制。如果不明白线程在做什么，不应该贸然地调用线程的 interrupt 方法，以为这样就能取消线程。

有一些程序模块以线程提供服务，它们应该封装取消 / 关闭操作，提供单独的取消 / 关闭方法给调用者，外部调用者应该调用这些方法以关闭线程而不是直接调用 interrupt。

## 并发工具

在 java.util.concurrent 中，Java 提供了一套并发工具包，其中包括很多易用且高性能的并发开发工具。

### 原子变量

在介绍 synchronized 时已经提到，使用 synchronized 解决内存可见性问题存在代价过高的问题，可以使用 volatile 修饰符代替。其实，对于竞态条件问题，如果面对的只是 count++ 这种代码，使用 synchronized 成本也是很高的，因为其中涉及获取锁、释放锁、等待锁、线程的上下文切换等。替代方案是，使用原子变量解决竞态条件问题.

Java 并发包中存在多种原子变量类型，其中的基本原子变量类型包括 AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference。其中，AtomicBoolean 常用于在程序中表示一个标志位，AtomicLong 常用于在程序中生成唯一的序列号，AtomicReference 用于以原子方式更新复杂类型。

对于某一具体类型的原子变量如何使用可以参考 API 文档，这里不过多赘述。

以 AtomicInteger 为例对原子变量作介绍。

#### 构造器

有两个构造器，一个无参，一个包含 int 型参数。无参时初始值是 0，有参时为给定的参数值。

#### 基本方法

有一些以原子方式实现的组合操作，如 getAndSet()，getAndIncrement()。

所有方法的实现都依赖另一个方法：CAS

```java
public final boolean compareAndSet(int expect, int update) {
    return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
}
```

该方法以原子方式实现了以下功能：如果当前值等于 expect，则更新为 update，否则不更新。如果更新成功，返回 true，否则返回 false。

具体的实现方法是调用了 unsafe 的 compareAndSwapInt 方法。unsafe 表示不安全，它的类型是 sun.misc. Unsafe，是 Sun 公司的私有实现。显然，一般的应用程序不应该使用此包下的内容。从更底层的角度看，一般的计算机系统都在硬件层次上直接支持 CAS 指令，程序员可以将 CAS 看作计算机的基本操作，无需过分担心。

#### 基本原理

AtomicInteger 中的主要成员是：

```java
private volatile int value
```

值得注意的是，此处使用了 volatile 以确保内存可见性，这是必须的。

大部分的更新方法都是类似的，以 incrementAndGet 为例：

```java
public final int incrementAndGet() {
    for(; ; ) {
        int current = get();
        int next = current + 1;
        if(compareAndSet(current, next))
            return next;
    }
}
```

可以看到，使用了 CAS 方法实现值更新。如果更新没有成功，说明 value 被别的线程改了，需要再去取最新值并尝试更新，直到成功为止。

可以显然地看到原子变量和 synchronized 在解决同一问题时思路的不同。**synchronized 是悲观的**，它假定冲突经常发生，所以先获取锁，后更新值。而**原子变量是乐观的**，它假定发生冲突的情况不多，所以即使发生冲突也一直尝试，直到成功为止。同时，**synchronized 是一种阻塞式的算法**，在得不到锁时线程将阻塞，等待其他线程唤醒它。这带来了上下文切换的消耗。而**原子变量更新值时是非阻塞式的**，线程一直在重试，一直在运行。没有阻塞就没有上下文切换。

事实证明，**对于比较简单的操作，无论是在低并发还是高并发情况下，乐观非阻塞方式的性能都远高于悲观阻塞式方式。**

#### CAS 实现锁

已经知道，可以使用 CAS 实现乐观非阻塞算法。其实，CAS 也可以用于实现悲观阻塞式算法。实际上，Java并发包中的所有阻塞式工具、容器、算法也都是基于 CAS 的（当然还需要其他工具的支持）。

一个简单的、借助 CAS 实现的锁如下所示：

```java
public class MyLock {
    private AtomicInteger status = new AtomicInteger(0);	// 0表示未锁定，1表示锁定
    
    public void lock() {
        while(! status.compareAndSet(0, 1)) {
            Thread.yield();
        }
    }
    
    public void unlock() {
        status.compareAndSet(1, 0);
    }
}
```

当然，这只是为了演示，实际开发中应当使用 Java 并发包中提供的更高效的类。

#### ABA 问题

CAS 的 使用可能会带来 ABA 问题：假设当前值为A，如果另一个线程先将A修改成B，再修改回成A，当前线程的 CAS 操作无法分辨当前值发生过变化。

在多数情况下，ABA 不是一个问题。如果 ABA 确实成为了影响程序的问题，解决方法是使用 AtomicStampedReference 类，其中实现的 CAS 方法在修改值的同时附加一个时间戳，只有值和时间戳都相同时才进行修改。

```java
public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp)
```

由于此时 CAS 需要在内部同时修改两个值，为了确保原子性，它会在内部将两个值封装进一个对象中，将对两个值的比较和修改变成对一个内部类对象的比较和修改。

### 显式锁

已经知道，synchronized 实现锁存在诸多的局限性。为了克服这些局限性，Java 并发包中提供了显式锁。显式锁位于 java.util.concurrent.locks 中，主要包括锁接口 Lock、实现类 ReentrantLock。

#### Lock

```java
public interface Lock {
    // 获取锁，得不到时会阻塞。不响应中断
    void lock();	
    // 与lock类似，但响应中断
    void lockInterruptibly() throws InterruptedException;
    // 尝试获取锁，成功返回true，失败返回false。无论成功与否，总是立即返回，不阻塞
    boolean tryLock();
    // 与tryLock()类似，但失败时阻塞。阻塞的最长时间不超过time。在规定时间内获得了锁返回true，否则返回false
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;	
    // 释放锁
    void unlock();	
    // 新建一个条件，一个Lock可以关联多个条件
    Condition newCondition();
}
```

与 synchronized 相比，显式锁支持以非阻塞方式获取锁、可以响应中断、可以限时，这使它灵活得多。

#### ReentrantLock 的使用

ReentrantLock 实现了 Lock 接口。与 synchronized 一样，它也可重入、也解决了竞态条件问题、也保证了内存可见性。

有两个构造方法，无参和有一个参数。参数为 boolean 类型，表示是否保证公平。所谓公平，就是等待时间最长的线程优先获得锁。保证公平会影响性能，一般也不需要，所以默认不保证，即无参时默认为 false。synchronized 也是不保证公平的。

应当说明的是，即使参数 fair 是 true， ReentrantLock 中不带参数的 tryLock 方法也是不保证公平的。

使用显式锁，一定要记得调用 unlock() 释放锁。**常见的方法是将 lock() 之后的代码包装到 try 语句内，在 finally 语句内释放锁。**

#### 死锁

只要使用锁就可能存在死锁问题。synchronized 对于死锁没有很好的解决办法，显式锁则不同，tryLock() 为解决死锁提供了可能。 

以银行转账为例。

```java
public class AccountMgr {
    public static class NoEnoughMoneyException extends Exception {}
    public static void transfer(Account from, Account to, double money)
        throws NoEnoughMoneyException {
        from.lock();
        try {
            to.lock();
            try {
                if(from.getMoney() >= money) {
                    from.reduce(money);
                    to.add(money);
                } else {
                    throw new NoEnoughMoneyException();
                }
            } finally {
                to.unlock();
            }
        } finally {
            from.unlock();
        }
    }
}
```

可以看到，如果使用与 synchronized 类似的方法获取锁，假设两个人同时向对方转账，那么死锁现象就会产生。使用 tryLock() 则不同。

```java
public static boolean tryTransfer(Account from, Account to, double money) throws NoEnoughMoneyException {
    if(from.tryLock()) {
        try {
            if(to.tryLock()) {
                try {
                    if(from.getMoney() >= money) {
                        from.reduce(money);
                        to.add(money);
                    } 
                    else {
                        throw new NoEnoughMoneyException();
                    }
                    return true;
                } 
                finally {
                    to.unlock();
                }
            }
        } 
        finally {
            from.unlock();
        }
    }
    
    return false;
}

public static void transfer(Account from, Account to, double money) throws NoEnoughMoneyException {
    boolean success = false;
    do {
        success = tryTransfer(from, to, money);
        if(! success) {
            Thread.yield();
        }
    } while (! success);
}
```

#### ReentrantLock 和 Synchronized 对比

可以看到，ReentrantLock 可以实现 Synchronized 的全部功能。而且，ReentrantLock 是非阻塞式的，可以响应中断，可以限时，比 Synchronized 更加灵活。然而，Synchronized 也有自己的优势。Synchronized 的使用更简单，代码少，不容易出错。

二者反应的编程思维也不同。Synchronized 代表了一种声明式的编程思维，程序员主要工作是声明同步需求，具体的实现交给 Java 实现，程序员不知道、也不关心其中的实现细节。ReentrantLock 代表了一种命令式编程思维，程序员需要实现所有的代码细节。

此外，二者的性能也存在差距。虽然在较新的 JVM 上 ReentrantLock 和 synchronized 的性能是接近的，但 Java 编译器和虚拟机能够自动优化 synchronized 的实现。譬如，对于没有锁竞争的场景，Java 编译器和虚拟机能够自动省略对锁获取 / 释放的调用。

总的来说，能用 synchronized 就用 synchronized 实现锁，不满足要求时再考虑 ReentrantLock。

### 显式条件

显式锁用于解决竞态条件问题，显式条件用于实现线程协作。如果说 ReentrantLock 与 synchronized 相对应，那么显式条件就与 wait / notify 相对应。

显式条件与显式锁是相互关联的。只有借助显式锁中定义的 newCondition 方法才能创建一个新的显式条件。

```java
// 新建一个条件，一个Lock可以关联多个条件
Condition newCondition();
```

Condition 表示显式条件，它本身是一个接口：

```java
public interface Condition {
    void await() throws InterruptedException;
    void awaitUninterruptibly();
    long awaitNanos(long nanosTimeout) throws InterruptedException;
    boolean await(long time, TimeUnit unit) throws InterruptedException;
    boolean awaitUntil(Date deadline) throws InterruptedException;
    void signal();
    void signalAll();
}
```

不难看出，await 对应 Object 中的 wait，signal 对应 Object 中的 notify，signalAll 对应 Object 中的 notifyAll。

与 wait 方法相似，await 方法也存在几个重载可以限定等待时间。这些方法都是响应中断的。如果发生了中断，会抛出 InterruptedException，但中断标志位会被清空。

此外，还有一个不响应中断的方法 awaitUninterruptibly。如果等待过程中发生了中断，那么该方法返回时中断标志位置 true。

一般而言，与 Object 的 wait 方法一样，调用 await 方法前需要先获取锁。如果没有锁，会抛出异常IllegalMonitorStateException。

# 参考资料

> 《Java编程的逻辑》马俊昌
>
> [Java substring() 方法 | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-string-substring.html)
